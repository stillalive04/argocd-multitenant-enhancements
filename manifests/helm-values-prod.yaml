# Helm Values for Production Environment
# Optimized for production workloads with high availability and security

global:
  environment: production
  domain: example.com
  
# Application Configuration
app:
  name: myapp-prod
  version: "1.2.3"  # Use specific version tags in production
  replicas: 6
  
  # Production settings
  debug: false
  logLevel: info
  hotReload: false
  
  # Production resource requirements
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"

# Database Configuration
database:
  host: postgres-prod.database.svc.cluster.local
  port: 5432
  name: myapp_prod
  # Production database settings
  maxConnections: 50
  connectionTimeout: 10s
  sslMode: require

# Redis Configuration
redis:
  host: redis-prod.cache.svc.cluster.local
  port: 6379
  database: 0
  maxConnections: 20
  # Enable Redis clustering for production
  cluster:
    enabled: true
    nodes: 3

# Service Configuration
service:
  type: ClusterIP
  port: 8080
  targetPort: 8080

# Ingress Configuration
ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: myapp-tls
      hosts:
        - myapp.example.com

# ConfigMap and Secrets
config:
  # Production configuration
  API_URL: "https://api.example.com"
  FEATURE_FLAGS: "debug=false,new_ui=false"
  LOG_FORMAT: "json"
  CACHE_TTL: "3600"
  
secrets:
  # Production secrets should be managed by external secret operators
  # These are placeholders - use external-secrets or sealed-secrets
  DATABASE_PASSWORD: "REPLACE_WITH_EXTERNAL_SECRET"
  API_KEY: "REPLACE_WITH_EXTERNAL_SECRET"
  JWT_SECRET: "REPLACE_WITH_EXTERNAL_SECRET"

# Autoscaling
autoscaling:
  enabled: true
  minReplicas: 6
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60

# Monitoring and Observability
monitoring:
  enabled: true
  prometheus:
    enabled: true
    scrapeInterval: 15s
  grafana:
    enabled: true
  jaeger:
    enabled: true
    samplingRate: 0.1  # 10% sampling for production
  alerts:
    enabled: true
    slack:
      webhook: "REPLACE_WITH_SLACK_WEBHOOK"
    email:
      recipients: ["ops-team@example.com"]

# Security Context (hardened for production)
securityContext:
  runAsNonRoot: true
  runAsUser: 10001
  fsGroup: 10001
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 10001
  fsGroup: 10001
  seccompProfile:
    type: RuntimeDefault

# Network Policies (enabled for production security)
networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: database
    - to:
        - namespaceSelector:
            matchLabels:
              name: cache

# Persistent Volume Claims
persistence:
  enabled: true
  storageClass: fast-ssd
  size: 10Gi
  accessMode: ReadWriteOnce

# Production Node Affinity
nodeSelector:
  environment: production
  node-type: application

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - myapp-prod
        topologyKey: kubernetes.io/hostname

tolerations:
  - key: "production"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 4  # Ensure at least 4 pods are always available

# Health Checks
healthcheck:
  livenessProbe:
    httpGet:
      path: /health/live
      port: 8080
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  readinessProbe:
    httpGet:
      path: /health/ready
      port: 8080
    initialDelaySeconds: 30
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3

# Init Containers
initContainers:
  - name: wait-for-db
    image: busybox:1.35
    command: ['sh', '-c', 'until nc -z postgres-prod.database.svc.cluster.local 5432; do echo waiting for db; sleep 2; done;']
    securityContext:
      runAsNonRoot: true
      runAsUser: 10001
      allowPrivilegeEscalation: false

# Backup Configuration
backup:
  enabled: true
  schedule: "0 2 * * *"  # Daily at 2 AM
  retention: "30d"
  storage:
    type: s3
    bucket: "myapp-prod-backups"

# Additional Labels
labels:
  environment: production
  team: platform
  version: v1.2.3
  criticality: high
  
# Annotations
annotations:
  deployment.kubernetes.io/revision: "1"
  argocd.argoproj.io/sync-wave: "2"
  backup.kubernetes.io/enabled: "true"
